---
title: "Link collection: 15"
date: 2022-10-29
draft: false
---

# Mateusz

## [Random Aeropress Recipe](https://thewinniewu.github.io/aeropress-dice/)

What makes life boring is routine.
Feeling that the current day is the same without changes as the one before.
But - I hear you cry - it'll never truly be the same, there will be always something that changes.
That's true, we perceive some events as the same when in fact they clearly are not carbon copies of each other.
Take for example going to work, you're doing something different today than your did yesterday.
But if the work is dull and repetitive, you'll learn to smooth those bumps of difference and come out with the conclusion that today's was the same as yesterday.
Over time some things that bring you joy and excite you start becoming background instead of a chosen foreground.
Why?
Because it's repetitive.
It has become a routine.
For me the word _routine_ has negative connotations when it does not imply anything that should be avoided.
What should be avoided is _repetitive routine_.

My routine is drinking coffee basically everyday.
I'm the snobby type that brings his own beans, grinder and the whole parade with him whenever and wherever he can.
It brings me joy, waking up and having this ritual of brewing a cup is sometimes more important for me then actually drinking what I made.
My secret is that I sometimes while going to sleep think about that coffee making process that will happen in the morning.
All and all there are mornings where I'm not really looking forward to making that coffee with the same passion as I used to.
My ritual has become a repetitive routine where every move is calculated and was the same the day before.
This stupid randomizer basically allows you to have fun, to be a human.
Do you notice any difference in the taste when you change this parameter?
You actually might!
And that routine might become an adventure that at the beginning was never something you signed up for.
To summarize: have fun, stop being text book perfect with things that bring joy to your life.

## [Handles are the better pointers](https://floooh.github.io/2018/06/17/handles-vs-pointers.html)

It's impossible to stress how earth moving, mind changing and perception shifting reading about data oriented design was for me.
This blog post was the easiest to wrap my head around and provided me with the biggest hammer I now have in my programmers tool box.
Hammer being the ability to create complex data structures with arrays and storing indexes into these arrays instead of raw pointers.
And abracadabra you've achieved the simplest serialization/deserialization in the world, reduced memory used and unknowingly decreased the risk of dereferencing an invalid pointer. 
All of that by simply changing what you store in your structs.
This thinking was allowed to flourish while working on a side project of [dis](https://github.com/mateuszradomski/dis).
To cut long story short, really thinking about how I'm going to store data simplified the code to the point where it's laughable to even show it to somebody.
If you design well the way data is stored in a simple and predictable way the simplest and most performant code just drops out on to your lap.
When looking back at my previous (unfortunately unfinished) project of [debag](https://github.com/mateuszradomski/debag) and the way I've handled storing DWARF data I can see that I've grown.
And in the direction that I wanted to grow when I was writing that unfinished project in the first place.
If you want to store a pointer to something think if the underlying memory will not be fragmented by that and if storing an index won't reduce the overall memory footprint.

## [Untangling Lifetimes: The Arena Allocator](https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator)

The arena allocator was one of the first stops on my data oriented design journey.
It started while reading [4coder's](https://4coder.net/) plugin framework source code and seeing the use of arenas for memory allocation.
For someone that really only understood the ability to allocate memory was fusing malloc/free into a pair.
I was intrigued because the idea of a scratch arena was immensely useful.
Outlining some size of allocated memory as available for use lower down the chain and freeing all of that at once by simply destroying the arena was beautifully simple.
Creating a scratch arena at some level and using it at every called function reduces the lifetime from a tree into a stack.
It's much simpler to think about something in ways of stacks instead of trees.
And do not think that everything can be solved by simple stacks.
Hard problems are hard.
But 90% of the time we are dealing with simple problems that are perfectly suited for simple solutions.
My advice for anybody wanting to simplify their code is to see problems that you do not have a simple solutions for and see how others did it.
Projects that are worth following are [ImGui](https://github.com/ocornut/imgui) or [Zig](https://github.com/ziglang/zig).
And while mentioning Zig I have to share [this](https://github.com/ziglang/zig) amazing talk by Andrew Kelley.
